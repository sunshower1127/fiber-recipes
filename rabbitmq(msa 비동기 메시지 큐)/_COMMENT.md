마이크로 아키텍쳐의 기본?
구독 형식으로 서버간 비동기 통신을 지원해줌.
큐도 제공해주고 ㅇㅇ
gRPC: 동기식 서비스 간 직접 API 호출 -> 빠른 작업
RabbitMQ: 비동기 이벤트 처리 및 시스템 전반의 느슨한 결합 -> 오래 걸리는 작업
이렇다네요

# RabbitMQ와 Fiber를 사용한 메시지 큐 예제

이 프로젝트는 Go Fiber 웹 프레임워크와 RabbitMQ 메시지 브로커를 함께 사용하는 예제입니다.

## RabbitMQ란?

RabbitMQ는 메시지 큐(Message Queue) 시스템으로, 애플리케이션 간 비동기 통신을 가능하게 해주는 미들웨어입니다. 다음과 같은 특징이 있습니다:

- **메시지 브로커**: 생산자(Producer)가 보낸 메시지를 소비자(Consumer)에게 전달
- **비동기 처리**: 시스템 간 즉각적인 응답이 필요 없는 작업을 분리
- **부하 분산**: 여러 작업자(Worker) 간에 작업 분배
- **내구성**: 메시지를 디스크에 저장해 시스템 장애 시에도 데이터 보존

## 이 예제의 구성 요소

1. **Fiber API 서버(main.go)**: 메시지를 생성하여 RabbitMQ에 전송하는 웹 서버
2. **워커(worker.go)**: RabbitMQ에서 메시지를 소비하는 별도 프로세스
3. **RabbitMQ 서버**: Docker 컨테이너로 실행되는 메시지 브로커

## 작동 방식

1. 사용자가 웹 브라우저에서 `http://127.0.0.1:3000/send?msg=Hello!`에 접속
2. Fiber 웹 서버가 요청을 받아 메시지를 RabbitMQ에 발행(publish)
3. RabbitMQ는 이 메시지를 큐에 저장
4. 워커 프로세스가 큐에서 메시지를 가져와(consume) 처리
5. 워커가 콘솔에 메시지 내용을 출력

## 사용 사례

이러한 아키텍처는 다음과 같은 상황에서 유용합니다:

- **시간이 오래 걸리는 작업 처리**: 이메일 전송, 이미지 처리, 보고서 생성
- **시스템 분리**: 각 구성 요소가 독립적으로 작동하여 확장성과 복원력 향상
- **부하 분산**: 여러 워커에게 작업을 분배하여 처리 속도 향상
- **피크 트래픽 처리**: 갑작스러운 요청 증가에도 안정적인 서비스 제공

이 예제는 마이크로서비스 아키텍처의 기본 개념을 학습하기 좋은 시작점입니다.

# RabbitMQ의 대표적인 사용 시나리오

## 1. 비동기 작업 처리

- **이메일/SMS 발송**: 사용자에게 알림을 보내는 작업을 비동기적으로 처리
- **파일 처리**: 대용량 파일 업로드, 이미지 리사이징, 동영상 인코딩 등
- **보고서 생성**: 시간이 오래 걸리는 데이터 집계 및 보고서 작업

## 2. 시스템 간 통합

- **마이크로서비스 통신**: 서로 다른 마이크로서비스 간의 느슨한 결합 통신
- **레거시 시스템 통합**: 새로운 시스템과 기존 레거시 시스템 간 데이터 교환
- **이벤트 기반 아키텍처**: 시스템 전반에 이벤트 발행 및 구독 패턴 구현

## 3. 부하 분산 및 확장성

- **작업 큐**: 워커 풀에 작업을 분배하여 처리량 증가
- **피크 시간 처리**: 트래픽 폭주 시 큐에 작업을 쌓아 점진적으로 처리
- **배치 처리**: 많은 양의 데이터를 배치로 모아 효율적으로 처리

## 4. 안정성 향상

- **서비스 분리**: 서비스 장애가 전체 시스템에 영향을 미치지 않도록 함
- **데이터 손실 방지**: 처리 실패한 메시지를 재시도 큐로 이동
- **백업 및 복구**: 시스템 장애 시 메시지 복구를 위한 메커니즘

## RabbitMQ vs gRPC

RabbitMQ와 gRPC는 서로 다른 문제를 해결하기 위한 도구로, 직접적인 비교 대상이라기보다 상호 보완적인 기술입니다:

### 주요 차이점

| 특성          | RabbitMQ             | gRPC                     |
| ------------- | -------------------- | ------------------------ |
| **통신 방식** | 비동기 메시징        | 동기/비동기 RPC 호출     |
| **사용 패턴** | 발행-구독, 작업 큐   | 서비스 간 직접 호출      |
| **중간 계층** | 메시지 브로커 필요   | 직접 통신 (중개자 없음)  |
| **지속성**    | 메시지 영속화 지원   | 기본적으로 지원하지 않음 |
| **통신 패턴** | 1:1, 1:N, Fan-out 등 | 주로 1:1 통신            |
| **부하 처리** | 큐를 통한 부하 완화  | 로드 밸런서 필요         |

### 적합한 사용 상황

- **RabbitMQ 적합**: 비동기 작업, 시스템 분리가 필요할 때, 부하 분산이 중요할 때
- **gRPC 적합**: 서비스 간 직접 통신, 높은 성능이 필요한 API 호출, 양방향 스트리밍

### 함께 사용하는 경우

많은 마이크로서비스 아키텍처에서 두 기술을 함께 사용합니다:

- gRPC: 동기식 서비스 간 직접 API 호출
- RabbitMQ: 비동기 이벤트 처리 및 시스템 전반의 느슨한 결합

이렇게 서로의 장점을 조합하여 더 견고하고 확장 가능한 시스템을 구축할 수 있습니다.
